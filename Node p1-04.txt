01-Projeto da aula anterior
Começando deste ponto? Você pode fazer o download do projeto do capítulo anterior para continuar seus estudos!
***********************************
02-Cadastro de livros
Vamos começar a desenvolver a funcionalidade de cadastro de livros da nossa aplicação. De volta ao nosso código, criaremos, na pasta "livros", uma pasta "form" contendo um arquivo form.marko, no qual construiremos o formulário de cadastro.

Isso será feito com um HTML comum:

<html>
    <body>
        <h1>Cadastro de livros</h1>

        <form action="/livros" method="post">

            <input type="hidden" id="id" name="id" />

            <div>
                <label for="titulo">Titulo:</label>
                <input type="text" id="titulo" name="titulo" placeholder="coloque o titulo" />
            </div>
            <div>
                <label for="preco">Preço:</label>
                <input type="text" id="preco" name="preco" placeholder="150.25" />
            </div>
            <div>
                <label for="descricao">Descrição:</label>
                <textarea cols="20" rows="10"  id="descricao" name="descricao" placeholder="fale sobre o livro"></textarea>
            </div>

            <input type="submit" value="Salvar" />
        </form>
    </body>
</html>
Como podemos analisar, temos um cabeçalho informando que essa é a página de cadastro; um formulário definido pela tag <form>, contendo um input oculto (para a id do nosso livro), campos de texto para o título e para o preço, e um textarea para a descrição do livro; um botão para submeter as informações do formulário; e a action indicando a URL para qual esses dados serão enviados, que nesse caso é /livros.

Também temos a definição do método de envio dos nossos dados, que é POST, de modo eles sejam encapsulados no corpo da requisição e não apareçam na URL.

Agora precisaremos criar duas novas rotas na nossa aplicação. A primeira delas deve possibilitar ao usuário o acesso a esse formulário que acabamos de criar, o que é bem simples.

Em rotas.js, definiremos a URL /livros/form e uma função de callback que receberá req, resp e será executada sempre que o usuário fizer a requisição para essa rota. Em seguida, devolveremos o template do nosso formulário com resp.marko(require('../views/livros/form/form.marko')).

app.get('/livros/form', function(req, resp) {
    resp.marko(require('../views/livros/form/form.marko'))
});
A nossa segunda rota será acessada sempre que o usuário fizer o envio dos dados do formulário. Essa rota, na verdade, já foi definida no nosso formulário:

<form action="/livros" method="post">
Mas como construiremos uma rota para o método POST do HTTP? É bem simples: utilizaremos a mesma sintaxe que em app.get(), substituindo-a pelo método post(), mantendo a função callback que será chamada. No corpo da função, como queremos apenas imprimir os dados que vieram do formulário, faremos console.log(req.body).

app.post('/livros', function(req, resp) {
    console.log(req.body);
});
Após salvarmos as alterações no nosso projeto, poderemos testá-lo no navegador. Para isso, executaremos a aplicação e acessaremos a URL http://localhost:3000/livros/form. O formulário simples que criamos em form.marko será exibido na tela:

formulário de cadastro de livros com os campos "título", "preço" e "descrição"

Se preenchermos os campos e clicarmos no botão "salvar", o navegador carregará a página por tempo indeterminado. Por que isso acontece?

No arquivo rotas.js, quando criamos o método post(), definimos apenas que o Node faria a exibição, no console, das informações do corpo da requisição. Ou seja, ainda precisamos definir uma visualização a ser exibida para o usuário, e faremos isso em aulas posteriores.

Por enquanto, precisamos saber se os dados no corpo da requisição realmente foram recebidos. Abrindo o Prompt de Comando, encontraremos... "undefined"?

Isso significa que o Node não conseguiu trazer os dados do formulário para o corpo da requisição. Pode ser uma surpresa, mas esse é o comportamento padrão e esperado do Node! Quer resolver essa situação? Pois acompanhe os próximos capítulos!
***********************************
03-Middlewares
Atualmente, quando preenchemos o formulário de cadastro de livros em http://localhost:3000/livros/form e clicamos em "salvar", recebemos no console um "undefined" ao invés dos dados que esperávamos.

Nosso objetivo agora é pegarmos as informações da requisição recebida do navegador antes de enviá-las à rota onde a lógica da nossa aplicação é implementada.

No Node, isso é possível por meio dos famosos middlewares, que funcionam como filtros. Com eles, podemos, por exemplo, manipular uma requisição antes que ela chegue na nossa lógica de negócios.

Dessa forma, conseguimos desenvolver diversos tipos de funcionalidades, como fazer auditoria nas requisições ou aplicar segurança em uma aplicação, verificando se o usuário tem ou não autorização para acessar determinada lógica.

Para começarmos a implementar mais essa funcionalidade, precisaremos, primeiramente, instalar o body-parser, o módulo do Node que nos ajudará nessa tarefa.

npm install body-parser@1.18.3 --save-exact
Feito isso, no custom-express.js, criaremos uma nova constante bodyParser que vai receber o retorno do require('body-parser'). Em seguida, usaremos o app (que é o objeto do express) para invocar o método use() recebendo exatamente o middleware que queremos definir na nossa aplicação.

Passaremos bodyParser, para o qual delegaremos a criação desse middleware, e o método urlencoded(), que define como o body-parser deve funcionar, e que está ligado à forma padrão de envio dos formulários HTML.

Esse método receberá um objeto JavaScript com a configuração extended : true. Dessa forma, ele estará habilitado a receber objetos complexos em formato .json vindos do nosso formulário no navegador.

Fazendo essa configuração, o bodyParser nos devolverá o middleware que precisamos. Existem ainda outras configurações que poderíamos fazer! Se você se interessar, pode se aprofundar mais nos conhecimentos sobre middlewares nos nossos exercícios!

Agora basta salvarmos nossas alterações e executarmos novamente nossa aplicação. Na página http://localhost:3000/livros/form, preencheremos os campos aleatoriamente - por exemplo, "teste", "100" e "descrição" -, e clicaremos em "Salvar". A página continuará carregando por tempo indeterminado, mas o importante nesse momento é a mensagem no console:

{ id: '', titulo: 'teste', preco: '100', descricao: 'descrição' }

Temos um id vazio, pois ainda não definimos nenhum; e o resto dos campos preenchidos exatamente como definimos no formulário. Sendo assim, já estamos aptos a fazer o cadastro de livros em nosso banco de dados!

De volta ao rotas.js, vamos copiar o código de listagem de livros, pois é sobre ele que construiremos o acesso ao banco:

const livroDao = new LivroDao(db);
livroDao.lista()
        .then(livros => resp.marko(
            require('../views/livros/lista/lista.marko'),
            {
                livros: livros
            }

        ))
        .catch(erro => console.log(erro));
Colaremos esse código na rota em que fazemos o método post() para /livros:

app.post('/livros', function(req, resp) {
    console.log(req.body);
    const livroDao = new LivroDao(db);
    livroDao.lista()
            .then(livros => resp.marko(
                require('../views/livros/lista/lista.marko'),
                {
                    livros: livros
                }

            ))
            .catch(erro => console.log(erro));
});
Vamos relembrar? Estamos criando uma instância de livroDao e passando a instância do banco de dados (db) que foi definida no início do arquivo rotas.js. Em seguida, utilizamos a instância do livroDao para chamar o método lista(). Dessa vez, queremos chamar um método adiciona(), que receberá req.body, em que estão armazenados os dados dos nossos livros.

A exemplo do lista(), esse método nos devolverá uma Promise, nos permitindo executar o método then() (que ainda não sabemos como se comportará). No catch(), continuaremos fazendo um console.log() do erro. Assim, teremos:

app.post('/livros', function(req, resp) {
    console.log(req.body);
    const livroDao = new LivroDao(db);
    livroDao.adiciona(req.body)
            .then()   
            .catch(erro => console.log(erro));
});
Ainda precisamos:

decidir o que fazer quando conseguirmos adicionar os livros no banco de dados
criar o método adiciona() no nosso livro-dao.js
Resolveremos esses problemas a seguir!
***********************************
04-exercícios-Aprofundando sobre middlewares
Para se aprofundar um pouco mais nas possibilidades que os middlewares nos oferecem, João pesquisou um pouco sobre o assunto e descobriu que o método use() do Express pode receber dois parâmetros, sendo o primeiro uma string que define as URLs que serão atendidas pelo middleware e como segundo parâmetro uma função. É essa função que irá definir o que o middleware deverá fazer e, por sua vez, recebe três parâmetros, a requisição, a resposta e uma função (normalmente chamada de next) que deve ser invocada para que o Express avance para o próximo middleware existente e caso não exista mais nenhum, passa a execução para a rota ativada. Sendo assim, a ordem em que os middlewares são definidos é de extrema importância! Além disso, um detalhe a ser observado, é que tudo que estiver antes da chamada da função next será executado antes da rota ativada e o que estiver após a chamada da função next será executado somente ao término da rota ativada!

Para saber mais: http://expressjs.com/pt-br/guide/using-middleware.html

Desse modo, para treinar o que aprendeu, nosso colega escreveu o seguinte código:

// custom-express.js

const express = require('express');
const app = express();

app.use('*', (req, res, next) => {
   console.log('1.1');
   next();
   console.log('1.2');
});

app.use('*', (req, res, next) => {
   console.log('2.1');
   next();
   console.log('2.2');
});
// rotas.js

module.exports = (app) => {

   app.get('/livros', function(req, resp) {
       console.log('listagem livros')
       const livroDao = new LivroDao(db);
       livroDao.lista()
               .then(livros => resp.marko(
                   require('../views/livros/lista/lista.marko'),
                   {
                       livros: livros
                   }
               ))
               .catch(erro => console.log(erro));
   });
};
A saída que nosso colega terá em seu terminal ao acessar a URL http://localhost:3000/livros será:

Alternativa correta
1.1
2.1
2.2
1.2
listagem livros

Incorreto! A saída correta seria:

1.1
2.1
listagem livros
2.2
1.2
Alternativa correta
1.1
1.2
2.1
2.2
listagem livros

Incorreto! A saída correta seria:

1.1
2.1
listagem livros
2.2
1.2
Alternativa correta
1.1
2.1
listagem livros
2.2
1.2

Muito bem, aluno! Está correto! É exatamente essa a saída que nosso colega irá obter!

Alternativa correta
listagem livros
1.1
2.1
2.2
1.2

Incorreto! A saída correta seria:

1.1
2.1
listagem livros
2.2
1.2
***********************************
05-exercícios-Sobre middlewares
Sobre middlewares, podemos afirmar corretamente:

Alternativa correta
Todo middleware será aplicado sempre para toda requisição.


Incorreto! Cada middleware será aplicado de acordo com o padrão de URL definido como primeiro parâmetro do método use().

Alternativa correta
Como o próprio nome indica, são trechos intermediários de código que são executados entre o envio da requisição e seu tratamento pela rota ativada!


Muito bem, aluno! Está correto! Essa é exatamente a definição de um middleware.

Alternativa correta
O middleware, de modo geral, é composto por um padrão de URLs que são usadas para o ativar e um callback que recebe a requisição, a resposta e uma função, normalmente chamada de next, que deve ser invocada para que o processamento da requisição siga em frente.


Muito bem, aluno! Está correto! De modo geral, o padrão de um middleware é:

const express = require('express');
const app = express();

app.use('*', (req, res, next) => {

   // código do middleware.
});
Alternativa correta
Uma aplicação possível de um middleware seria a contagem de tempo gasto ao executar uma rota.


Muito bem, aluno! Está correto! Dado que dentro do middleware tudo que está antes da chamada da função next é executado antes da rota ativada e o que estiver após a chamada de next é executado após a rota, então poderíamos fazer a contagem do tempo da seguinte forma:

const express = require('express');
const app = express();

app.use('*', (req, res, next) => {
   const inicio = new Date().getTime();
   next();
   const final = new Date().getTime();

   const milissegundosDecorridos = final - inicio;
});
***********************************
06-
***********************************
07-
***********************************
08-
***********************************
09-
***********************************
10-
